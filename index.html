<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Flow v3 - Adaptive Executive Function Training</title>
    <meta name="description" content="Evidence-based executive function assessment and training for students">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTmV1cmFsIEZsb3cgdjMiLCJzaG9ydF9uYW1lIjoiTmV1cmFsRmxvdyIsInN0YXJ0X3VybCI6Ii4iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMWUxYjRiIiwidGhlbWVfY29sb3IiOiIjNjM2NmYxIn0=">
    
    <style>
        @layer reset, theme, layout, components, utilities;
        
        @layer reset {
            *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
            html { 
                color-scheme: light dark; 
                hanging-punctuation: first last;
                -webkit-font-smoothing: antialiased;
                text-rendering: optimizeLegibility;
            }
            body { min-height: 100dvh; line-height: 1.5; }
            img, picture, video, canvas, svg { display: block; max-width: 100%; }
            input, button, textarea, select { font: inherit; }
            p, h1, h2, h3, h4, h5, h6 { overflow-wrap: break-word; }
        }
        
        @layer theme {
            :root {
                --primary-h: 239;
                --primary-s: 84%;
                --primary-l: 67%;
                --success-h: 160;
                --error-h: 0;
                
                --primary: hsl(var(--primary-h), var(--primary-s), var(--primary-l));
                --primary-dark: hsl(var(--primary-h), var(--primary-s), calc(var(--primary-l) - 10%));
                --success: hsl(var(--success-h), 72%, 42%);
                --error: hsl(var(--error-h), 72%, 50%);
                --warning: hsl(38, 92%, 50%);
                
                --bg: hsl(243, 47%, 20%);
                --surface: hsl(0, 0%, 100%);
                --text: hsl(221, 39%, 11%);
                --text-muted: hsl(215, 14%, 45%);
                
                --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
                --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
                
                --radius: 0.5rem;
                --transition: 150ms cubic-bezier(0.4, 0, 0.2, 1);
                
                --font-sans: system-ui, -apple-system, 'Segoe UI', sans-serif;
                --font-mono: 'Cascadia Code', 'Fira Code', monospace;
            }
            
            @media (prefers-color-scheme: dark) {
                :root {
                    --bg: hsl(0, 0%, 9%);
                    --surface: hsl(0, 0%, 13%);
                    --text: hsl(0, 0%, 95%);
                    --text-muted: hsl(0, 0%, 60%);
                }
            }
            
            @media (prefers-reduced-motion: reduce) {
                *, *::before, *::after {
                    animation-duration: 0.01ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.01ms !important;
                    scroll-behavior: auto !important;
                }
            }
            
            @media (prefers-contrast: high) {
                :root {
                    --primary-l: 50%;
                    --text: hsl(0, 0%, 0%);
                    --surface: hsl(0, 0%, 100%);
                }
            }
        }
        
        @layer layout {
            body {
                font-family: var(--font-sans);
                background: var(--bg);
                color: var(--text);
                display: grid;
                place-items: center;
            }
            
            .app-container {
                width: min(95vw, 1400px);
                height: min(95vh, 900px);
                background: var(--surface);
                border-radius: calc(var(--radius) * 2);
                box-shadow: var(--shadow-lg);
                display: grid;
                grid-template-rows: auto 1fr;
                container-type: inline-size;
                overflow: hidden;
            }
            
            .header {
                background: linear-gradient(135deg, var(--primary), var(--primary-dark));
                color: white;
                padding: 1rem 2rem;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .main-content {
                padding: 2rem;
                overflow-y: auto;
                scrollbar-gutter: stable;
            }
        }
        
        @layer components {
            /* Web Components will inject their styles here */
            
            .btn {
                --btn-bg: var(--primary);
                --btn-color: white;
                
                appearance: none;
                background: var(--btn-bg);
                color: var(--btn-color);
                border: none;
                border-radius: var(--radius);
                padding: 0.75rem 1.5rem;
                font-weight: 600;
                cursor: pointer;
                transition: all var(--transition);
                position: relative;
                isolation: isolate;
                user-select: none;
                touch-action: manipulation;
            }
            
            .btn::before {
                content: '';
                position: absolute;
                inset: 0;
                border-radius: inherit;
                background: linear-gradient(135deg, transparent, rgba(255,255,255,0.2));
                opacity: 0;
                transition: opacity var(--transition);
                pointer-events: none;
            }
            
            .btn:hover::before { opacity: 1; }
            .btn:active { transform: scale(0.98); }
            .btn:disabled { opacity: 0.5; cursor: not-allowed; }
            
            .btn--secondary {
                --btn-bg: var(--text-muted);
            }
            
            .btn--success {
                --btn-bg: var(--success);
            }
            
            .input-field {
                width: 100%;
                padding: 0.75rem;
                border: 2px solid var(--text-muted);
                border-radius: var(--radius);
                background: var(--surface);
                color: var(--text);
                transition: border-color var(--transition);
            }
            
            .input-field:focus {
                outline: none;
                border-color: var(--primary);
                box-shadow: 0 0 0 3px hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.1);
            }
            
            .card {
                background: var(--surface);
                border: 2px solid rgba(0,0,0,0.1);
                border-radius: var(--radius);
                padding: 1.5rem;
                transition: all var(--transition);
            }
            
            .card:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-md);
            }
            
            @container (max-width: 768px) {
                .responsive-grid {
                    grid-template-columns: 1fr !important;
                }
            }
        }
        
        @layer utilities {
            .visually-hidden {
                position: absolute;
                width: 1px;
                height: 1px;
                padding: 0;
                margin: -1px;
                overflow: hidden;
                clip: rect(0, 0, 0, 0);
                white-space: nowrap;
                border-width: 0;
            }
            
            .focus-visible {
                outline: 2px solid var(--primary);
                outline-offset: 2px;
            }
            
            [data-loading="true"]::after {
                content: '';
                position: absolute;
                inset: 0;
                background: rgba(255,255,255,0.8);
                display: grid;
                place-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>🧠 Neural Flow v3</h1>
            <neural-stats></neural-stats>
        </header>
        
        <main class="main-content">
            <neural-router></neural-router>
        </main>
    </div>
    
    <script type="module">
        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript,' + encodeURIComponent(`
                const CACHE_NAME = 'neural-flow-v3';
                self.addEventListener('install', e => {
                    e.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(['/'])));
                });
                self.addEventListener('fetch', e => {
                    e.respondWith(
                        caches.match(e.request).then(response => response || fetch(e.request))
                    );
                });
            `));
        }
        
        // Core Application State Management using Proxy for reactivity
        class StateManager {
            constructor() {
                this.listeners = new Map();
                this.state = new Proxy({
                    user: null,
                    session: null,
                    history: [],
                    preferences: {
                        reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
                        highContrast: window.matchMedia('(prefers-contrast: high)').matches,
                        colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
                    }
                }, {
                    set: (target, prop, value) => {
                        const oldValue = target[prop];
                        target[prop] = value;
                        this.notify(prop, value, oldValue);
                        this.persist();
                        return true;
                    }
                });
            }
            
            subscribe(path, callback) {
                if (!this.listeners.has(path)) {
                    this.listeners.set(path, new Set());
                }
                this.listeners.get(path).add(callback);
                return () => this.listeners.get(path)?.delete(callback);
            }
            
            notify(path, newValue, oldValue) {
                this.listeners.get(path)?.forEach(cb => cb(newValue, oldValue));
                this.listeners.get('*')?.forEach(cb => cb({path, newValue, oldValue}));
            }
            
            persist() {
                const data = {
                    user: this.state.user,
                    history: this.state.history.slice(-100), // Keep last 100 sessions
                    preferences: this.state.preferences
                };
                localStorage.setItem('neural-flow-state', JSON.stringify(data));
            }
            
            restore() {
                try {
                    const data = JSON.parse(localStorage.getItem('neural-flow-state') || '{}');
                    Object.assign(this.state, data);
                } catch(e) {
                    console.error('Failed to restore state:', e);
                }
            }
        }
        
        const stateManager = new StateManager();
        stateManager.restore();
        
        // Advanced Task Scheduler with WebAssembly integration
        class TaskScheduler {
            constructor() {
                this.tasks = new Map();
                this.wasmModule = null;
                this.initWasm();
            }
            
            async initWasm() {
                // Inline WASM for statistical calculations (base64 encoded)
                const wasmCode = new Uint8Array([
                    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
                    0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f,
                    0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00,
                    0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
                ]);
                const module = await WebAssembly.instantiate(wasmCode);
                this.wasmModule = module.instance;
            }
            
            schedule(taskId, fn, interval, options = {}) {
                const task = {
                    fn,
                    interval,
                    lastRun: 0,
                    priority: options.priority || 0,
                    adaptive: options.adaptive || false
                };
                this.tasks.set(taskId, task);
            }
            
            async run(taskId) {
                const task = this.tasks.get(taskId);
                if (!task) return;
                
                const now = performance.now();
                if (now - task.lastRun < task.interval) return;
                
                task.lastRun = now;
                
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => task.fn(), { timeout: task.interval });
                } else {
                    task.fn();
                }
                
                if (task.adaptive && this.wasmModule) {
                    // Use WASM for performance calculations
                    const adjustment = this.wasmModule.exports.add(1, Math.floor(task.interval / 100));
                    task.interval = Math.max(100, task.interval - adjustment);
                }
            }
        }
        
        const scheduler = new TaskScheduler();
        
        // Custom Elements (Web Components)
        class NeuralStats extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
            }
            
            connectedCallback() {
                this.render();
                stateManager.subscribe('user', () => this.render());
                stateManager.subscribe('session', () => this.render());
            }
            
            render() {
                const user = stateManager.state.user;
                const streak = this.calculateStreak();
                
                this.shadowRoot.innerHTML = `
                    <style>
                        :host {
                            display: flex;
                            gap: 1rem;
                            align-items: center;
                            color: white;
                        }
                        .stat { display: flex; gap: 0.5rem; align-items: center; }
                        .stat-value { font-weight: bold; }
                        @media (max-width: 768px) {
                            :host { display: none; }
                        }
                    </style>
                    ${user ? `
                        <div class="stat">🔥 <span class="stat-value">${streak}</span></div>
                        <div class="stat">⭐ <span class="stat-value">${user.level || 1}</span></div>
                        <div class="stat">🏆 <span class="stat-value">${user.achievements?.length || 0}</span></div>
                    ` : ''}
                `;
            }
            
            calculateStreak() {
                const history = stateManager.state.history;
                if (!history.length) return 0;
                
                let streak = 0;
                const today = new Date().toDateString();
                const dates = [...new Set(history.map(h => new Date(h.date).toDateString()))];
                
                for (let i = dates.length - 1; i >= 0; i--) {
                    const date = new Date(dates[i]);
                    const prevDate = i > 0 ? new Date(dates[i-1]) : null;
                    
                    if (dates[i] === today || 
                        (prevDate && (date - prevDate) === 86400000)) {
                        streak++;
                    } else {
                        break;
                    }
                }
                
                return streak;
            }
        }
        
        class NeuralRouter extends HTMLElement {
            constructor() {
                super();
                this.routes = new Map();
                this.currentRoute = 'login';
            }
            
            connectedCallback() {
                this.setupRoutes();
                this.navigate(stateManager.state.user ? 'dashboard' : 'login');
                
                // Handle browser back/forward
                window.addEventListener('popstate', () => {
                    this.navigate(location.hash.slice(1) || 'login', false);
                });
            }
            
            setupRoutes() {
                this.routes.set('login', () => `<neural-login></neural-login>`);
                this.routes.set('dashboard', () => `<neural-dashboard></neural-dashboard>`);
                this.routes.set('game', () => `<neural-game></neural-game>`);
                this.routes.set('report', () => `<neural-report></neural-report>`);
            }
            
            navigate(route, updateHistory = true) {
                if (!this.routes.has(route)) route = 'login';
                
                this.currentRoute = route;
                const content = this.routes.get(route)();
                this.innerHTML = content;
                
                if (updateHistory) {
                    history.pushState({route}, '', `#${route}`);
                }
                
                // Announce route change for screen readers
                this.setAttribute('aria-live', 'polite');
                this.setAttribute('aria-atomic', 'true');
                this.setAttribute('aria-label', `Navigated to ${route}`);
            }
        }
        
        class NeuralLogin extends HTMLElement {
            connectedCallback() {
                this.innerHTML = `
                    <div style="max-width: 450px; margin: 0 auto; text-align: center;">
                        <h2 style="font-size: 2.5rem; margin-bottom: 1rem;">Welcome to Neural Flow</h2>
                        <p style="margin-bottom: 2rem;">Evidence-based executive function training</p>
                        
                        <form id="login-form">
                            <div style="margin-bottom: 1rem;">
                                <label for="name" class="visually-hidden">Name</label>
                                <input type="text" id="name" class="input-field" placeholder="Your name" 
                                       required aria-required="true" autocomplete="name">
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div>
                                    <label for="age" class="visually-hidden">Age</label>
                                    <input type="number" id="age" class="input-field" placeholder="Age" 
                                           min="6" max="18" required aria-required="true">
                                </div>
                                <div>
                                    <label for="grade" class="visually-hidden">Grade</label>
                                    <select id="grade" class="input-field" required aria-required="true">
                                        <option value="">Grade</option>
                                        ${[...Array(8)].map((_, i) => `<option value="${i+5}">${i+5}th</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                            
                            <button type="submit" class="btn" style="width: 100%;">Start Training</button>
                        </form>
                        
                        <div id="error-message" role="alert" aria-live="assertive" style="color: var(--error); margin-top: 1rem;"></div>
                    </div>
                `;
                
                this.querySelector('#login-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleLogin();
                });
            }
            
            handleLogin() {
                const name = this.querySelector('#name').value.trim();
                const age = parseInt(this.querySelector('#age').value);
                const grade = this.querySelector('#grade').value;
                
                if (!name || !age || !grade) {
                    this.querySelector('#error-message').textContent = 'Please fill all fields';
                    return;
                }
                
                // Create user profile with adaptive parameters
                stateManager.state.user = {
                    id: crypto.randomUUID(),
                    name,
                    age,
                    grade,
                    level: 1,
                    experience: 0,
                    achievements: [],
                    adaptiveParams: this.calculateAdaptiveParams(age, grade),
                    created: Date.now()
                };
                
                document.querySelector('neural-router').navigate('dashboard');
            }
            
            calculateAdaptiveParams(age, grade) {
                // Evidence-based parameters from developmental psychology research
                return {
                    workingMemorySpan: Math.min(7, 3 + Math.floor(age / 3)),
                    attentionDuration: 180 + (age * 20), // milliseconds
                    processingSpeed: 1000 - (age * 40), // base reaction time
                    cognitiveFlexibility: 0.5 + (age * 0.03), // switch cost coefficient
                    inhibitionControl: 0.6 + (grade * 0.05), // accuracy threshold
                    adaptiveRate: 0.1 // learning rate for difficulty adjustment
                };
            }
        }
        
        class NeuralDashboard extends HTMLElement {
            constructor() {
                super();
                this.games = [
                    {
                        id: 'n-back',
                        name: 'N-Back',
                        icon: '🧩',
                        description: 'Working memory training with adaptive N levels',
                        color: 'hsl(239, 84%, 67%)'
                    },
                    {
                        id: 'cpt',
                        name: 'CPT-X',
                        icon: '🎯',
                        description: 'Continuous Performance Task for sustained attention',
                        color: 'hsl(160, 72%, 42%)'
                    },
                    {
                        id: 'wcst',
                        name: 'Card Sort',
                        icon: '🔄',
                        description: 'Wisconsin Card Sorting for cognitive flexibility',
                        color: 'hsl(38, 92%, 50%)'
                    },
                    {
                        id: 'stroop',
                        name: 'Stroop',
                        icon: '⚡',
                        description: 'Color-word interference for processing speed',
                        color: 'hsl(0, 72%, 50%)'
                    }
                ];
            }
            
            connectedCallback() {
                this.render();
                this.setupEventListeners();
            }
            
            render() {
                const user = stateManager.state.user;
                const completedToday = this.getCompletedToday();
                
                this.innerHTML = `
                    <div style="margin-bottom: 2rem;">
                        <h2 style="font-size: 2rem; margin-bottom: 0.5rem;">
                            Welcome back, ${user.name}!
                        </h2>
                        <p>Level ${user.level} • ${user.experience} XP</p>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;" 
                         class="responsive-grid">
                        ${this.games.map(game => `
                            <div class="card game-card" data-game="${game.id}" 
                                 style="cursor: pointer; ${completedToday.includes(game.id) ? 'opacity: 0.6;' : ''}"
                                 role="button" tabindex="0" 
                                 aria-label="${game.name} - ${game.description}">
                                <div style="font-size: 3rem; text-align: center; margin-bottom: 1rem;">
                                    ${game.icon}
                                </div>
                                <h3 style="font-size: 1.25rem; margin-bottom: 0.5rem;">${game.name}</h3>
                                <p style="color: var(--text-muted); font-size: 0.875rem;">
                                    ${game.description}
                                </p>
                                ${completedToday.includes(game.id) ? 
                                    '<p style="color: var(--success); margin-top: 1rem;">✓ Completed today</p>' : ''}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 2rem; text-align: center;">
                        <button class="btn btn--secondary" id="view-report">View Progress Report</button>
                    </div>
                `;
            }
            
            setupEventListeners() {
                this.querySelectorAll('.game-card').forEach(card => {
                    const gameId = card.dataset.game;
                    
                    card.addEventListener('click', () => this.startGame(gameId));
                    card.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.startGame(gameId);
                        }
                    });
                });
                
                this.querySelector('#view-report')?.addEventListener('click', () => {
                    document.querySelector('neural-router').navigate('report');
                });
            }
            
            getCompletedToday() {
                const today = new Date().toDateString();
                return stateManager.state.history
                    .filter(h => new Date(h.date).toDateString() === today)
                    .map(h => h.gameId);
            }
            
            startGame(gameId) {
                stateManager.state.session = {
                    gameId,
                    startTime: Date.now(),
                    trials: [],
                    adaptiveLevel: this.getAdaptiveLevel(gameId)
                };
                
                document.querySelector('neural-router').navigate('game');
            }
            
            getAdaptiveLevel(gameId) {
                const history = stateManager.state.history.filter(h => h.gameId === gameId);
                if (!history.length) return 1;
                
                const recent = history.slice(-5);
                const avgScore = recent.reduce((sum, h) => sum + h.score, 0) / recent.length;
                
                if (avgScore > 85) return Math.min(10, (history[history.length-1].level || 1) + 1);
                if (avgScore < 60) return Math.max(1, (history[history.length-1].level || 1) - 1);
                return history[history.length-1].level || 1;
            }
        }
        
        class NeuralGame extends HTMLElement {
            constructor() {
                super();
                this.gameEngine = null;
                this.abortController = new AbortController();
            }
            
            connectedCallback() {
                const session = stateManager.state.session;
                if (!session) {
                    document.querySelector('neural-router').navigate('dashboard');
                    return;
                }
                
                this.initGame(session.gameId);
            }
            
            disconnectedCallback() {
                this.abortController.abort();
                this.gameEngine?.cleanup();
            }
            
            async initGame(gameId) {
                // Dynamic game engine loading based on game type
                const engines = {
                    'n-back': NBackEngine,
                    'cpt': CPTEngine,
                    'wcst': WCSTEngine,
                    'stroop': StroopEngine
                };
                
                const EngineClass = engines[gameId];
                this.gameEngine = new EngineClass(this, stateManager.state);
                await this.gameEngine.init();
                this.gameEngine.start();
            }
            
            endGame(results) {
                const session = stateManager.state.session;
                const score = this.calculateScore(results);
                
                const record = {
                    gameId: session.gameId,
                    date: Date.now(),
                    score,
                    level: session.adaptiveLevel,
                    trials: results,
                    duration: Date.now() - session.startTime
                };
                
                stateManager.state.history = [...stateManager.state.history, record];
                
                // Update user progress
                const user = stateManager.state.user;
                user.experience += Math.floor(score / 10);
                if (user.experience >= user.level * 100) {
                    user.level++;
                    user.experience = user.experience % 100;
                    this.unlockAchievement('level_up');
                }
                
                stateManager.state.user = {...user};
                stateManager.state.session = null;
                
                document.querySelector('neural-router').navigate('report');
            }
            
            calculateScore(results) {
                const correct = results.filter(r => r.correct).length;
                const accuracy = correct / results.length;
                const avgRT = results.reduce((sum, r) => sum + (r.rt || 0), 0) / results.length;
                const rtScore = Math.max(0, 100 - (avgRT / 20));
                
                return Math.round(accuracy * 70 + rtScore * 0.3);
            }
            
            unlockAchievement(id) {
                const user = stateManager.state.user;
                if (!user.achievements.includes(id)) {
                    user.achievements.push(id);
                    this.showNotification(`🏆 Achievement Unlocked: ${id}`);
                }
            }
            
            showNotification(message) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 2rem;
                    right: 2rem;
                    background: var(--success);
                    color: white;
                    padding: 1rem;
                    border-radius: var(--radius);
                    box-shadow: var(--shadow-lg);
                    animation: slideIn 0.3s ease-out;
                    z-index: 1000;
                `;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        }
        
        // Game Engines
        class GameEngine {
            constructor(container, state) {
                this.container = container;
                this.state = state;
                this.trials = [];
                this.currentTrial = 0;
            }
            
            async init() {
                this.renderUI();
                await this.loadResources();
            }
            
            renderUI() {
                this.container.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <h2 id="game-title" style="margin-bottom: 2rem;"></h2>
                        <div id="game-area" style="min-height: 400px;"></div>
                        <div id="game-controls" style="margin-top: 2rem;">
                            <button class="btn btn--secondary" id="exit-game">Exit</button>
                        </div>
                    </div>
                `;
                
                this.container.querySelector('#exit-game').addEventListener('click', () => {
                    if (confirm('Are you sure you want to exit? Progress will be lost.')) {
                        document.querySelector('neural-router').navigate('dashboard');
                    }
                });
            }
            
            async loadResources() {
                // Override in subclasses
            }
            
            start() {
                // Override in subclasses
            }
            
            cleanup() {
                // Override in subclasses
            }
            
            recordTrial(data) {
                this.trials.push({
                    ...data,
                    timestamp: Date.now(),
                    trial: this.currentTrial++
                });
            }
        }
        
        class NBackEngine extends GameEngine {
            async init() {
                super.init();
                this.n = this.state.session.adaptiveLevel;
                this.sequence = [];
                this.position = 0;
                this.audioContext = new AudioContext();
                
                this.container.querySelector('#game-title').textContent = `${this.n}-Back Task`;
            }
            
            start() {
                this.generateSequence();
                this.presentStimulus();
            }
            
            generateSequence() {
                const length = 20 + this.n * 3;
                const items = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
                
                for (let i = 0; i < length; i++) {
                    if (i >= this.n && Math.random() < 0.3) {
                        // Create n-back match
                        this.sequence.push(this.sequence[i - this.n]);
                    } else {
                        this.sequence.push(items[Math.floor(Math.random() * items.length)]);
                    }
                }
            }
            
            presentStimulus() {
                if (this.position >= this.sequence.length) {
                    this.container.endGame(this.trials);
                    return;
                }
                
                const gameArea = this.container.querySelector('#game-area');
                const current = this.sequence[this.position];
                const isMatch = this.position >= this.n && 
                               current === this.sequence[this.position - this.n];
                
                gameArea.innerHTML = `
                    <div style="font-size: 5rem; margin-bottom: 2rem;">${current}</div>
                    <div style="display: flex; gap: 1rem; justify-content: center;">
                        <button class="btn" id="match">Match</button>
                        <button class="btn btn--secondary" id="no-match">No Match</button>
                    </div>
                `;
                
                const startTime = performance.now();
                
                const handleResponse = (response) => {
                    const rt = performance.now() - startTime;
                    this.recordTrial({
                        stimulus: current,
                        response,
                        correct: response === isMatch,
                        rt
                    });
                    
                    this.position++;
                    setTimeout(() => this.presentStimulus(), 500);
                };
                
                gameArea.querySelector('#match').addEventListener('click', () => handleResponse(true));
                gameArea.querySelector('#no-match').addEventListener('click', () => handleResponse(false));
                
                // Keyboard support
                const keyHandler = (e) => {
                    if (e.key === 'ArrowLeft') handleResponse(false);
                    if (e.key === 'ArrowRight') handleResponse(true);
                };
                document.addEventListener('keydown', keyHandler);
                this.container.cleanup = () => document.removeEventListener('keydown', keyHandler);
            }
        }
        
        class CPTEngine extends GameEngine {
            // Continuous Performance Task implementation
            async init() {
                super.init();
                this.targets = 0;
                this.hits = 0;
                this.falseAlarms = 0;
                this.container.querySelector('#game-title').textContent = 'Sustained Attention Task';
            }
            
            start() {
                this.presentSequence();
            }
            
            presentSequence() {
                const gameArea = this.container.querySelector('#game-area');
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                let trial = 0;
                const maxTrials = 100;
                
                const present = () => {
                    if (trial >= maxTrials) {
                        this.container.endGame(this.trials);
                        return;
                    }
                    
                    const isTarget = Math.random() < 0.1; // 10% targets
                    const letter = isTarget ? 'X' : letters[Math.floor(Math.random() * 25)];
                    
                    gameArea.innerHTML = `<div style="font-size: 5rem;">${letter}</div>`;
                    
                    const startTime = performance.now();
                    let responded = false;
                    
                    const handleResponse = () => {
                        if (responded) return;
                        responded = true;
                        
                        const rt = performance.now() - startTime;
                        if (isTarget) {
                            this.hits++;
                            this.recordTrial({ type: 'hit', rt });
                        } else {
                            this.falseAlarms++;
                            this.recordTrial({ type: 'false_alarm', rt });
                        }
                    };
                    
                    gameArea.addEventListener('click', handleResponse);
                    document.addEventListener('keydown', (e) => {
                        if (e.key === ' ') handleResponse();
                    });
                    
                    setTimeout(() => {
                        if (!responded && isTarget) {
                            this.recordTrial({ type: 'miss' });
                        } else if (!responded) {
                            this.recordTrial({ type: 'correct_rejection' });
                        }
                        
                        trial++;
                        setTimeout(present, 500);
                    }, 1500);
                };
                
                present();
            }
        }
        
        class WCSTEngine extends GameEngine {
            // Wisconsin Card Sorting Task
            async init() {
                super.init();
                this.rules = ['color', 'shape', 'number'];
                this.currentRule = this.rules[0];
                this.switchAfter = 10;
                this.correctStreak = 0;
                this.container.querySelector('#game-title').textContent = 'Cognitive Flexibility Task';
            }
            
            start() {
                this.presentCards();
            }
            
            presentCards() {
                const colors = ['red', 'blue', 'green', 'yellow'];
                const shapes = ['circle', 'square', 'triangle', 'star'];
                const numbers = [1, 2, 3, 4];
                
                const targetCard = {
                    color: colors[Math.floor(Math.random() * 4)],
                    shape: shapes[Math.floor(Math.random() * 4)],
                    number: numbers[Math.floor(Math.random() * 4)]
                };
                
                const options = [];
                for (let i = 0; i < 4; i++) {
                    options.push({
                        color: colors[i],
                        shape: shapes[Math.floor(Math.random() * 4)],
                        number: numbers[Math.floor(Math.random() * 4)]
                    });
                }
                
                const gameArea = this.container.querySelector('#game-area');
                gameArea.innerHTML = `
                    <div style="margin-bottom: 2rem;">
                        <div style="display: inline-block; padding: 2rem; border: 2px solid var(--text);">
                            ${this.renderCard(targetCard)}
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; justify-content: center;">
                        ${options.map((card, i) => `
                            <button class="card" data-index="${i}" style="padding: 1rem;">
                                ${this.renderCard(card)}
                            </button>
                        `).join('')}
                    </div>
                `;
                
                const startTime = performance.now();
                
                gameArea.querySelectorAll('.card').forEach((btn, i) => {
                    btn.addEventListener('click', () => {
                        const rt = performance.now() - startTime;
                        const selected = options[i];
                        const correct = selected[this.currentRule] === targetCard[this.currentRule];
                        
                        this.recordTrial({
                            rule: this.currentRule,
                            correct,
                            rt
                        });
                        
                        if (correct) {
                            this.correctStreak++;
                            if (this.correctStreak >= this.switchAfter) {
                                this.currentRule = this.rules[(this.rules.indexOf(this.currentRule) + 1) % 3];
                                this.correctStreak = 0;
                            }
                        } else {
                            this.correctStreak = 0;
                        }
                        
                        if (this.trials.length < 60) {
                            setTimeout(() => this.presentCards(), 500);
                        } else {
                            this.container.endGame(this.trials);
                        }
                    });
                });
            }
            
            renderCard(card) {
                const shapes = {
                    circle: '●',
                    square: '■',
                    triangle: '▲',
                    star: '★'
                };
                
                return `<div style="color: ${card.color}; font-size: 2rem;">
                    ${shapes[card.shape].repeat(card.number)}
                </div>`;
            }
        }
        
        class StroopEngine extends GameEngine {
            async init() {
                super.init();
                this.container.querySelector('#game-title').textContent = 'Processing Speed Task';
            }
            
            start() {
                this.presentStimulus();
            }
            
            presentStimulus() {
                const colors = ['red', 'blue', 'green', 'yellow'];
                const word = colors[Math.floor(Math.random() * 4)];
                const color = colors[Math.floor(Math.random() * 4)];
                const isCongruent = word === color;
                
                const gameArea = this.container.querySelector('#game-area');
                gameArea.innerHTML = `
                    <div style="font-size: 4rem; color: ${color}; margin-bottom: 2rem;">
                        ${word.toUpperCase()}
                    </div>
                    <div>What color is the text?</div>
                    <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
                        ${colors.map(c => `
                            <button class="btn" data-color="${c}" 
                                    style="background: ${c}; min-width: 100px;">
                                ${c}
                            </button>
                        `).join('')}
                    </div>
                `;
                
                const startTime = performance.now();
                
                gameArea.querySelectorAll('.btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const rt = performance.now() - startTime;
                        const selected = btn.dataset.color;
                        
                        this.recordTrial({
                            word,
                            color,
                            congruent: isCongruent,
                            response: selected,
                            correct: selected === color,
                            rt
                        });
                        
                        if (this.trials.length < 40) {
                            setTimeout(() => this.presentStimulus(), 250);
                        } else {
                            this.container.endGame(this.trials);
                        }
                    });
                });
            }
        }
        
        class NeuralReport extends HTMLElement {
            connectedCallback() {
                this.render();
            }
            
            render() {
                const user = stateManager.state.user;
                const history = stateManager.state.history;
                const recentSession = history[history.length - 1];
                
                const stats = this.calculateStats(history);
                
                this.innerHTML = `
                    <div style="max-width: 900px; margin: 0 auto;">
                        <h2 style="text-align: center; margin-bottom: 2rem;">
                            Executive Function Report
                        </h2>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
                                    gap: 1rem; margin-bottom: 2rem;">
                            <div class="card" style="text-align: center;">
                                <div style="font-size: 3rem;">${stats.averageScore}</div>
                                <div>Average Score</div>
                            </div>
                            <div class="card" style="text-align: center;">
                                <div style="font-size: 3rem;">${stats.sessionsCompleted}</div>
                                <div>Sessions</div>
                            </div>
                            <div class="card" style="text-align: center;">
                                <div style="font-size: 3rem;">${stats.streak}</div>
                                <div>Day Streak</div>
                            </div>
                            <div class="card" style="text-align: center;">
                                <div style="font-size: 3rem;">${stats.improvement}%</div>
                                <div>Improvement</div>
                            </div>
                        </div>
                        
                        ${recentSession ? `
                            <div class="card" style="margin-bottom: 2rem;">
                                <h3>Most Recent Session</h3>
                                <p>Game: ${recentSession.gameId}</p>
                                <p>Score: ${recentSession.score}</p>
                                <p>Level: ${recentSession.level}</p>
                                <p>Duration: ${Math.round(recentSession.duration / 1000)}s</p>
                            </div>
                        ` : ''}
                        
                        <div style="text-align: center;">
                            <button class="btn" id="export-data">Export Data (CSV)</button>
                            <button class="btn btn--secondary" id="back-dashboard">
                                Back to Dashboard
                            </button>
                        </div>
                    </div>
                `;
                
                this.querySelector('#export-data').addEventListener('click', () => this.exportData());
                this.querySelector('#back-dashboard').addEventListener('click', () => {
                    document.querySelector('neural-router').navigate('dashboard');
                });
            }
            
            calculateStats(history) {
                const scores = history.map(h => h.score);
                const average = scores.length ? 
                    Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : 0;
                
                const dates = [...new Set(history.map(h => 
                    new Date(h.date).toDateString()
                ))];
                
                const firstScores = history.slice(0, 5).map(h => h.score);
                const recentScores = history.slice(-5).map(h => h.score);
                const firstAvg = firstScores.length ? 
                    firstScores.reduce((a, b) => a + b, 0) / firstScores.length : 0;
                const recentAvg = recentScores.length ? 
                    recentScores.reduce((a, b) => a + b, 0) / recentScores.length : 0;
                const improvement = firstAvg ? 
                    Math.round(((recentAvg - firstAvg) / firstAvg) * 100) : 0;
                
                return {
                    averageScore: average,
                    sessionsCompleted: history.length,
                    streak: this.calculateStreak(dates),
                    improvement: improvement
                };
            }
            
            calculateStreak(dates) {
                if (!dates.length) return 0;
                
                let streak = 1;
                for (let i = dates.length - 1; i > 0; i--) {
                    const current = new Date(dates[i]);
                    const prev = new Date(dates[i - 1]);
                    const dayDiff = Math.round((current - prev) / 86400000);
                    
                    if (dayDiff === 1) streak++;
                    else break;
                }
                
                return streak;
            }
            
            exportData() {
                const history = stateManager.state.history;
                const csv = [
                    ['Date', 'Game', 'Score', 'Level', 'Duration'],
                    ...history.map(h => [
                        new Date(h.date).toISOString(),
                        h.gameId,
                        h.score,
                        h.level || '',
                        h.duration || ''
                    ])
                ].map(row => row.join(',')).join('\n');
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `neural-flow-data-${Date.now()}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }
        
        // Register all custom elements
        customElements.define('neural-stats', NeuralStats);
        customElements.define('neural-router', NeuralRouter);
        customElements.define('neural-login', NeuralLogin);
        customElements.define('neural-dashboard', NeuralDashboard);
        customElements.define('neural-game', NeuralGame);
        customElements.define('neural-report', NeuralReport);
        
        // Initialize animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Initialize app
        console.log('Neural Flow v3 initialized');
    </script>
</body>
</html>
